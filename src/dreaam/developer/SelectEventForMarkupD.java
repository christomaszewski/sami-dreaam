package dreaam.developer;

import sami.event.InputEvent;
import sami.event.OutputEvent;
import sami.event.ReflectedEventSpecification;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.EventObject;
import java.util.Hashtable;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.tree.*;

/**
 * Dialog window that lets you select InputEvents and OutputEvents for SAMI
 * transitions
 *
 * @author pscerri
 */
public class SelectEventForMarkupD extends javax.swing.JDialog {

    DefaultMutableTreeNode treeRoot = null;
    CheckBoxNodeRenderer renderer = new CheckBoxNodeRenderer();
    ArrayList<ReflectedEventSpecification> eventsOnVertex;
    // This insanity is required because CheckBox node is replacing the event spec with a string.
    private Hashtable<ToolTipTreeNode, ReflectedEventSpecification> nodeMapping = new Hashtable<ToolTipTreeNode, ReflectedEventSpecification>();
    // This contains the events that are selected for caller class to pull out
    ArrayList<ReflectedEventSpecification> selectedEventSpecs = new ArrayList<ReflectedEventSpecification>();

    public SelectEventForMarkupD(java.awt.Frame parent, boolean modal, ArrayList<ReflectedEventSpecification> eventsOnVertex) {
        super(parent, modal);
        initComponents();
        setTitle("SelectEventForMarkupD");
        this.eventsOnVertex = eventsOnVertex;

        eventT.setCellRenderer(renderer);
        eventT.setCellEditor(new CheckBoxNodeEditor(eventT));
        treeRoot = new javax.swing.tree.DefaultMutableTreeNode("JTree");

        // Work out events from flie
        populateEvents(treeRoot, eventsOnVertex);

        // Expand the tree for easier viewing
        eventT.setModel(new javax.swing.tree.DefaultTreeModel(treeRoot));
        for (int i = 0; i < eventT.getRowCount(); i++) {
            eventT.expandRow(i);
        }

        ToolTipManager.sharedInstance().registerComponent(eventT);
    }

    /**
     * Reads in a file looking like:
     *
     * service >input >>"datamodel.Events.Output.SensorConfigurationEvent" "Set
     * the UAV sensors" >output
     *
     * @param treeRoot
     * @return
     */
    public boolean populateEvents(DefaultMutableTreeNode parentNode, ArrayList<ReflectedEventSpecification> eventsOnVertex) {
        if (eventsOnVertex == null) {
            Logger.getLogger(this.getClass().getName()).log(Level.WARNING, "List of events is null!");
            return false;
        }

        for (ReflectedEventSpecification event : eventsOnVertex) {
            // Store spec in a ToolTipTreeNode, which is stored in the tree and a lookup table
            ToolTipTreeNode node = new ToolTipTreeNode(event, "");
            nodeMapping.put(node, event);
            parentNode.add(node);
        }
        return true;
    }

    private String[] splitOnString(String string, String split) {
        ArrayList<String> list = new ArrayList<String>();
        int startIndex = 0;
        int endIndex = string.indexOf(split, startIndex);
        while (endIndex != -1) {
            list.add(string.substring(startIndex, endIndex));
            startIndex = endIndex + 1;
            endIndex = string.indexOf(split, startIndex);
        }
        String[] ret = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            ret[i] = list.get(i);
        }
        return ret;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        eventT = new javax.swing.JTree();
        okB = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("JTree");
        javax.swing.tree.DefaultMutableTreeNode treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Service");
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("SAMI");
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Proxy");
        treeNode1.add(treeNode2);
        eventT.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        eventT.setEditable(true);
        eventT.setRootVisible(false);
        jScrollPane1.setViewportView(eventT);

        okB.setText("OK");
        okB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okBActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, okB, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 98, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 523, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 486, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(okB)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void okBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okBActionPerformed
        ArrayList<ReflectedEventSpecification> newSelectedEvents = new ArrayList<ReflectedEventSpecification>();

        Enumeration e = treeRoot.breadthFirstEnumeration();
        while (e.hasMoreElements()) {
            DefaultMutableTreeNode n = (DefaultMutableTreeNode) e.nextElement();
            if (n.isLeaf()) {

                Object userObject = n.getUserObject();
                // Turns into a CheckBoxNode if touched
                if (userObject instanceof CheckBoxNode) {
                    CheckBoxNode node = (CheckBoxNode) userObject;
                    boolean isSelected = node.isSelected();
                    if (isSelected) {
                        // This only triggers if the checkbox went from "unchecked" to "checked"
                        selectedEventSpecs.add(nodeMapping.get(n));
                    }
                }
            }
        }

        setVisible(false);
    }//GEN-LAST:event_okBActionPerformed

    // Adapted from http://www.java2s.com/Code/Java/Swing-JFC/CheckBoxNodeTreeSample.htm
    class CheckBoxNodeRenderer implements TreeCellRenderer {

        private JCheckBox leafRenderer = new JCheckBox();
        private DefaultTreeCellRenderer nonLeafRenderer = new DefaultTreeCellRenderer();
        Color selectionBorderColor, selectionForeground, selectionBackground,
                textForeground, textBackground;

        protected JCheckBox getLeafRenderer() {
            return leafRenderer;
        }

        public CheckBoxNodeRenderer() {

            Font fontValue;
            fontValue = UIManager.getFont("Tree.font");
            if (fontValue != null) {
                leafRenderer.setFont(fontValue);
            }
            Boolean booleanValue = (Boolean) UIManager.get("Tree.drawsFocusBorderAroundIcon");
            leafRenderer.setFocusPainted((booleanValue != null) && (booleanValue.booleanValue()));

            selectionBorderColor = UIManager.getColor("Tree.selectionBorderColor");
            selectionForeground = UIManager.getColor("Tree.selectionForeground");
            selectionBackground = UIManager.getColor("Tree.selectionBackground");
            textForeground = UIManager.getColor("Tree.textForeground");
            textBackground = UIManager.getColor("Tree.textBackground");

        }

        public Component getTreeCellRendererComponent(JTree tree, Object value,
                boolean selected, boolean expanded, boolean leaf, int row,
                boolean hasFocus) {

            Component returnValue;
            if (leaf) {
                // Add an event class checkbox
                // This is the text that will appear before the "checkbox" is manipulated which causes an actual CheckBoxNode to be created from the ToolTipTreeNode...I think
                leafRenderer.setText(value.toString());
                // Should the checkbox be marked as checked?
                boolean previouslySelected = false;
                if (nodeMapping.containsKey(value)) {
                    ReflectedEventSpecification r = nodeMapping.get(value);
                    if (selectedEventSpecs != null && selectedEventSpecs.indexOf(r) >= 0) {
                        previouslySelected = true;
                    }
                } else {
                    //System.out.println("No sign of " + value + " " + value.getClass() + " in " + nodeMapping.keySet());
                }

                leafRenderer.setSelected(previouslySelected);

                leafRenderer.setEnabled(tree.isEnabled());
                // Input/Output coloring
                if ((value != null) && (value instanceof ToolTipTreeNode)) {
                    ToolTipTreeNode tttn = (ToolTipTreeNode) value;

                    leafRenderer.setToolTipText(tttn.getToolTipText());
                    if (tttn.isInput) {
                        leafRenderer.setBorderPainted(true);
                        leafRenderer.setBorder(new LineBorder(Color.GREEN));
                    } else if (tttn.isOutput) {
                        leafRenderer.setBorderPainted(true);
                        leafRenderer.setBorder(new LineBorder(Color.RED));
                    }
                    Object userObject = tttn.getUserObject();
                    if (userObject instanceof CheckBoxNode) {
                        // The object will be a CheckBoxNode if the "checkbox" has been manipulated previously...as opposed to it being a ReflectedEventSpecification as expected
                        CheckBoxNode node = (CheckBoxNode) userObject;
                        leafRenderer.setText(node.getText());
                        leafRenderer.setSelected(node.isSelected());
                        // System.out.println("This was called, with " + node.isSelected());
                    }
                }

                if (selected) {
                    leafRenderer.setForeground(selectionForeground);
                    leafRenderer.setBackground(selectionBackground);
                } else {
                    leafRenderer.setForeground(textForeground);
                    leafRenderer.setBackground(textBackground);
                }

                returnValue = leafRenderer;
            } else {
                returnValue = nonLeafRenderer.getTreeCellRendererComponent(tree,
                        value, selected, expanded, leaf, row, hasFocus);
            }
            return returnValue;
        }
    }

    class CheckBoxNodeEditor extends AbstractCellEditor implements TreeCellEditor {

        CheckBoxNodeRenderer renderer = new CheckBoxNodeRenderer();
        ChangeEvent changeEvent = null;
        JTree tree;

        public CheckBoxNodeEditor(JTree tree) {
            this.tree = tree;
        }

        public Object getCellEditorValue() {
            JCheckBox checkbox = renderer.getLeafRenderer();
            CheckBoxNode checkBoxNode = new CheckBoxNode(checkbox.getText(), checkbox.isSelected());
            return checkBoxNode;
        }

        public boolean isCellEditable(EventObject event) {
            boolean returnValue = false;
            if (event instanceof MouseEvent) {
                MouseEvent mouseEvent = (MouseEvent) event;
                TreePath path = tree.getPathForLocation(mouseEvent.getX(),
                        mouseEvent.getY());
                if (path != null) {
                    Object node = path.getLastPathComponent();
                    if ((node != null) && (node instanceof ToolTipTreeNode)) {
                        ToolTipTreeNode treeNode = (ToolTipTreeNode) node;
                        Object userObject = treeNode.getUserObject();
                        // returnValue = ((treeNode.isLeaf()) && (userObject instanceof CheckBoxNode));
                        returnValue = treeNode.isLeaf();

                        // System.out.println("Is editable returning " + returnValue + " " + treeNode.isLeaf() + " " + (userObject instanceof CheckBoxNode));
                    }
                }
            }


            return returnValue;
        }

        public Component getTreeCellEditorComponent(JTree tree, Object value,
                boolean selected, boolean expanded, boolean leaf, int row) {

            Component editor = renderer.getTreeCellRendererComponent(tree, value,
                    true, expanded, leaf, row, true);

            // editor always selected / focused
            ItemListener itemListener = new ItemListener() {
                public void itemStateChanged(ItemEvent itemEvent) {
                    if (stopCellEditing()) {
                        fireEditingStopped();
                    }
                }
            };
            if (editor instanceof JCheckBox) {
                ((JCheckBox) editor).addItemListener(itemListener);
            }

            return editor;
        }
    }

    class CheckBoxNode {

        String text;
        boolean selected;

        public CheckBoxNode(String text, boolean selected) {
            this.text = text;
            this.selected = selected;
        }

        public boolean isSelected() {
            return selected;
        }

        public void setSelected(boolean newValue) {
            selected = newValue;
        }

        public String getText() {
            return text;
        }

        public void setText(String newValue) {
            text = newValue;
        }

        public String toString() {
            return getClass().getName() + "[" + text + "/" + selected + "]";
        }
    }

    class ToolTipTreeNode extends DefaultMutableTreeNode {

        private String toolTipText;
        public boolean isOutput = false;
        public boolean isInput = false;

        public ToolTipTreeNode(Object obj, String toolTipText) {
            super(obj);
            this.toolTipText = toolTipText;

            Logger.getLogger(this.getClass().getName()).log(Level.FINE, "Got object of type: " + obj.getClass(), this);

            if (obj instanceof ReflectedEventSpecification) {
                ReflectedEventSpecification rfs = (ReflectedEventSpecification) obj;
                try {
                    Class c = Class.forName(rfs.getClassName());
                    if (OutputEvent.class.isAssignableFrom(c)) {
                        isOutput = true;
                    }
                    if (InputEvent.class.isAssignableFrom(c)) {
                        isInput = true;
                    }
                } catch (ClassNotFoundException ex) {
                    Logger.getLogger(SelectEventForMarkupD.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }

        public String getToolTipText() {
            return toolTipText;
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTree eventT;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton okB;
    // End of variables declaration//GEN-END:variables
}
